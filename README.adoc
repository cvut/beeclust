= beeclust
:toc:
:note-caption: :information_source:
:warning-caption: :warning:


BeeClust swarming algorithm with Python's NumPy.


== ZadÃ¡nÃ­ Ãºkolu

VaÅ¡Ã­m Ãºkolem za 5 bodÅ¯ je vytvoÅ™it tÅ™Ã­du `BeeClust` v modulu `beeclust`: simulaci
shlukovacÃ­ho algoritmu http://heikohamann.de/pub/schmickl_beeclust_2011.pdf[BeeClust].
Tento algoritmus je zaloÅ¾enÃ½ na chovÃ¡nÃ­ vÄel v pÅ™Ã­rodÄ› a jejich rojenÃ­ v mÃ­stech s
ideÃ¡lnÃ­ teplotou (pÅ™ibliÅ¾nÄ› 32â€“38Â°C). HlavnÃ­ vlastnostÃ­ je, Å¾e vÄely jsou hloupÃ© a
nevÃ­ nic o svÃ©m okolÃ­ a nemajÃ­ tÃ©mÄ›Å™ Å¾Ã¡dnou pamÄ›Å¥. Tento algoritmus lze v praxi vyuÅ¾Ã­vat
pÅ™i prÃ¡ci s jednoduchÃ½mi autonomnÃ­mi roboty.


=== Popis algoritmu ğŸ

Pro zjednoduÅ¡enÃ­ pracujeme s 2D mÅ™Ã­Å¾kou s diskrÃ©tnÃ­m Äasem (jednotlivÃ© "tiky") a diskrÃ©tnÃ­m
prostorem (celoÄÃ­selnÃ© souÅ™adnice).

1. VÄela se pohybuje korelovanou nÃ¡hodnou prochÃ¡zkou (s pravdÄ›podobnostÃ­ `p_changedir`
   se zmÄ›nÃ­ smÄ›r pohybu vÄely nÃ¡hodnÄ› jednÃ­m ze zbÃ½vajÃ­cÃ­ch tÅ™Ã­ smÄ›rÅ¯, jinak je smÄ›r pohybu
   zachovÃ¡n). JestliÅ¾e se pÅ™ed tÃ­m nepohybovala (na poÄÃ¡tku nebo byla *zastavena*), vybÃ­rÃ¡
   se smÄ›r dalÅ¡Ã­ho kroku nÃ¡hodnÄ› ze vÅ¡ech ÄtyÅ™ smÄ›rÅ¯.
2. Pokud vÄela narazÃ­ do pÅ™ekÃ¡Å¾ky (zeÄ, zdroj tepla/chladu), s pravdÄ›podobnostÃ­ `p_wall`
   se *zastavÃ­*, jinak se otoÄÃ­ o 180Â° a v pÅ™Ã­Å¡tÃ­m kroku pokraÄuje v pohybu (krok 1).
3. Pokud vÄela potkÃ¡ (narazÃ­ na)  jinou vÄelu, s pravdÄ›podobnostÃ­ `p_meet` se *zastavÃ­*,
   jinak v pÅ™Ã­Å¡tÃ­m kroku pokraÄuje v pohybu (krok 1).
4. Pokud mÃ¡ vÄela *zastavit*, zÅ¯stÃ¡vÃ¡ na mÃ­stÄ› po dobu `t`, kterÃ¡ zÃ¡visÃ­ na teplotÄ› pozice,
   kde stojÃ­ (viz vzorec nÃ­Å¾e). Po uplynutÃ­ Äasu `t` se pokraÄuje krokem 1.


Pro vÃ½poÄet Äasu *zastavenÃ­* pouÅ¾Ã­vÃ¡me vzorec `t = int(k_stay / (1 + abs(T_ideal - T_local)))`, kde:

* `k_stay` je nastavitelnÃ½ koeficient
* `T_ideal` je teplota, kterou majÃ­ vÄely nejradÅ¡i
* `T_local` je teplota aktuÃ¡lnÃ­ pozice vÄely

MinimÃ¡lnÄ› se vÅ¡ak ÄekÃ¡ dobu `min_wait` (nastavitelnÃ¡ konstanta).


=== Mapa

VÄely se pohybujÃ­ po 2D mapÄ› reprezentovanÃ© maticÃ­ celÃ½ch ÄÃ­sel s nÃ¡sledujÃ­cÃ­m kÃ³dovÃ¡nÃ­m:

* `0` = prÃ¡zdnÃ¡ pozice
* `1` = vÄela mÃ­Å™Ã­cÃ­ na sever (nahoru)
* `2` = vÄela mÃ­Å™Ã­cÃ­ na vÃ½chod (vpravo)
* `3` = vÄela mÃ­Å™Ã­cÃ­ na jih (dolÅ¯)
* `4` = vÄela mÃ­Å™Ã­cÃ­ na zÃ¡pad (vlevo)
* `5` = zeÄ (s absolutnÃ­ tepelnou izolacÃ­)
* `6` = ohÅ™Ã­vaÄ, zdroj tepla `T_heater &#8805; T_env`
* `7` = chladiÄ, zdroj chladu `T_cooler &#8804; T_env`
* `-t` = vÄela ÄekajÃ­cÃ­ `t` (`-1` je reprezentace vÄely, kterÃ¡ nevÃ­, kam jde, v pÅ™Ã­Å¡tÃ­m
  kroku se rozhodne - zmÄ›nÃ­ se na vÄelu reprezentovanou ÄÃ­slem od `1` do `4`, a v dalÅ¡Ã­m
  kroku se zaÄne pohybovat dle popisu vÃ½Å¡e)

Pozice mimo definovanou mapu fungujÃ­ jako zeÄ â€“ tzn. nelze se pohybovat ani propagovat
teplo pÅ™es okraje mapy.

=== Teplota

Teplo se po mapÄ› Å¡Ã­Å™Ã­ ve vÅ¡ech 8 smÄ›rech (narozdÃ­l od pohybu vÄel) a poÄÃ­tÃ¡ se v
reÃ¡lnÃ½ch ÄÃ­slech typu `float`.

1. Na pozici, kde je zeÄ, teplota nenÃ­ definovÃ¡na (`NaN`)
2. Na pozici, kde je ohÅ™Ã­vaÄ, je vÅ¾dy teplota `T_heater`
3. Na pozici, kde je chladiÄ, je vÅ¾dy teplota `T_cooler`
4. Na pozicÃ­ch, kde nic nenÃ­ nebo jsou tam vÄely, se teplota poÄÃ­tÃ¡ podle vzorce:

  * `T = T_env + k_temp * (max(heating, 0) - max(cooling, 0))`
  * `heating = (1 / dist_heater) * (T_heater - T_env)`
  * `cooling = (1 / dist_cooler) * (T_env - T_cooler)`
  * vzdÃ¡lenost ohÅ™Ã­vaÄe `dist_heater` (resp. chladiÄe) je vzdÃ¡lenost *nejbliÅ¾Å¡Ã­ho*
    ohÅ™Ã­vaÄe (resp. chladiÄe) v poÄtu krokÅ¯ 8 smÄ›ry s uvaÅ¾ovÃ¡nÃ­m zdÃ­ a ostatnÃ­ch
    chladiÄÅ¯/ohÅ™Ã­vaÄÅ¯ jako pÅ™ekÃ¡Å¾ek
  * `k_temp` je nastavitelnÃ½ koeficient ovlivÅˆujÃ­cÃ­ tepelnou vodivost prostÅ™edÃ­

=== RozhranÃ­ tÅ™Ã­dy `BeeClust`

VÃ¡mi implementovanÃ¡ tÅ™Ã­da bude splÅˆovat specifikovanÃ© rozhranÃ­:


[source,python]
----
class BeeClust:

    def __init__(self, map, p_changedir=0.2, p_wall=0.8, p_meet=0.8, k_temp=0.9,
                 k_stay=50, T_ideal=35, T_heater=40, T_cooler=5, T_env=22, min_wait=2):
        ...

    ...  # required methods & properties (see assignment & tests)

b = BeeClust(some_numpy_map)
----

* `b.map` obsahuje mapu jako `numpy` celoÄÃ­selnou matici
* `b.heatmap` obsahuje tepelnou mapu  jako `numpy` matici reÃ¡lnÃ½ch ÄÃ­sel
* `b.bees` obsahuje seznam dvojic `(x, y)` reprezentujÃ­cÃ­ pozice vÄel
* `b.swarms` obsahuje seznam seznamÅ¯ dvojic `(x, y)` reprezentujÃ­cÃ­ pozice se sousedÃ­cÃ­mi
  vÄelami (4 smÄ›ry); napÅ™Ã­klad `[[(0,0), (0,1), (0,2), (1,0)], [(2,3)], [(3,5), (4,5)]]` pro
  mapu se sedmi vÄelami ve tÅ™ech rojÃ­ch; na poÅ™adÃ­ v seznamech nezÃ¡leÅ¾Ã­
* `b.score` vypoÄÃ­tÃ¡ prÅ¯mÄ›rnou teplotu vÄel
* `b.tick()` provede 1 krok simulace algoritmu a vrÃ¡tÃ­ poÄet vÄel, kterÃ© se pohnuly
* `b.forget()` vÅ¡echny vÄely zapomenou svoji dobu ÄekÃ¡nÃ­ a smÄ›r, kterÃ½m Å¡ly; v pÅ™Ã­Å¡tÃ­m kroku
  vylosujÃ­ nÃ¡hodnÄ› smÄ›r a v dalÅ¡Ã­m kroku se opÄ›t dajÃ­ do pohybu
* `b.recalculate_heat()` vynutÃ­ pÅ™epoÄtenÃ­ `b.heatmap` (napÅ™Ã­klad po zmÄ›nÄ› mapy `b.map`
  bez tvorby novÃ© simulace)

== AutomatickÃ© testy

SouÄÃ¡stÃ­ zadÃ¡nÃ­ jsou testy ve sloÅ¾ce `tests`.
Pro spuÅ¡tÄ›nÃ­ testÅ¯ nainstalujte do virtuÃ¡lnÃ­ho prostÅ™edÃ­ balÃ­ky `pytest` a `numpy`.
Å½Ã¡dnÃ½ speciÃ¡lnÃ­ setup nenÃ­ vyÅ¾adovÃ¡n.
Testy trvajÃ­ Å™Ã¡dovÄ› niÅ¾Å¡Ã­ jednotky vteÅ™in, pokud se vaÅ¡e algoritmy nezacyklÃ­.

[source,console]
$ python -m pytest -v tests

Testy si mÅ¯Å¾ete zkopÃ­rovat k sobÄ› do repozitÃ¡Å™e, povaÅ¾ujte je za Public Domain.
NÄ›kterÃ© testy obsahujÃ­ vysvÄ›tlujÃ­cÃ­ komentÃ¡Å™.

Testy musÃ­ jÃ­t spustit z koÅ™enovÃ©ho adresÃ¡Å™e vaÅ¡eho repozitÃ¡Å™e a vÅ¡echny musÃ­ projÃ­t.
Je to podmÃ­nka nutnÃ¡ (nikoli vÅ¡ak dostaÄujÃ­cÃ­) k zÃ­skÃ¡nÃ­ maximÃ¡lnÃ­ho poÄtu bodÅ¯.

== OdevzdÃ¡nÃ­ Ãºkolu

Odkaz na repozitÃ¡Å™ s aplikacÃ­ nÃ¡m poÅ¡lete e-mailem.
Pro odevzdÃ¡nÃ­ v repozitÃ¡Å™i (jinÃ½ neÅ¾ pro `filabel` a `pandas`) nastavte tag `v0.1`.

TermÃ­n odevzdÃ¡nÃ­ je u tÃ©to Ãºlohy klasicky v pondÄ›lÃ­ (vÄetnÄ›) za 12 dnÃ­.
